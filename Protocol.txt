There are three parts --- the frontend (F), the server (S), and the backend (B).

Server:
	The server is started with a TCP port (specified with --port, and the default is 8222), a UNIX socket (specified with --socket, and the default is /tmp/shmem.sock), a ram file (specified with --file, and will maybe create one by default), and number of segments to create (specified with --segments, and the default is 100).

	Then, the server opens the ram file, and gets its size. By default, each segment will be given the same size (as its easier to calculate offsets), with the possibility that there may be some space on the drive left over --- there is also the possibility of dividing the space so that all of the space will be used, but some segments will be slightly bigger than others.

	Then a thread-safe set is created, and is populated with all numbers between 1 and {segments}, inclusive. An array is then created that maps each segment to their offset and size.

	A dictionary backend_to_info is then created that maps backend id to a socket connection, and a lock which will be used to make sure communication to it is thread-safe. This dictionary is thread-safe.

	A this point, the server is ready to start, so the server starts listening on the TCP port, and the socket.

Use msync with mmap. Test with backend that compares data sent with hash that is sent with it and see if it matches, and quits if any of them are false

If a duplicate backend tries to connect, just quit in BackendAccept immediately

Sockets should be shared_ptr

Messages:
	The frontend and backend sends messages to the server (and vice-versa) using their respective channels. Every message is 12 bytes, and are interpreted as 3 integers of 4 bytes each. The first number always denotes the message type, and the other two numbers are used as arguments that may optionally be used. 


Backend:
	The backend can connect to the server over the unix socket S is listening on. It should continually try to connect until it does. Once it does, this will be the channel B will use.

	Once B accepts the new connection, it will immediately spawn a thread that runs the BackendAccept function.

	Inside the BackendAccept function:
		The server will perpetually listen for new messages. 

		If the server disconnects for any reason, the backend will:
			* Remove the entry from backend_to_info, if it exists
			* Relinquish control of any corresponding segments, if they exist
			* Close all corresponding frontend connections, if they exist


		The first message the backend will send upon connection is INIT,{id},{unused}. A backend's id must be globally unique. 

		Once the message is received by the backend, a new entry in backend_to_info is made, in the form of {id}: {.conn = {accepted conn}, .lock= {new lock}}

Frontend:
	The frontend can connect to the server of the TCP port S is listening on. It should continually try to connect until it does. Once it does, this will be the channel F will use.

	Once B accepts the new connection, it will immediately spawn a thread that runs the FrontendAccept function.
	
	Inside the FrontendAccept function:
		The server will perpetually listen for new messages.

		If the client disconnects, shut down everything as needed.

		The first message the client will send upon connection is CONNECT,{id},{unused}, where the id is the id of the corresponding backend it wants to connect to.
			
			First, the client will be appended to the queue at unconnected_frontends[{id}]

			The server then sends a CONNECT,0 message to the backend

			The backend receives the message, and makes a new connection NC to S, and waits for a response. 

			In NC's BackendAccept:
				NC sends the message CONNECT,{id}

				The first client in unconnected_frontends[{id}] will be taken: conn_to_conn[{frontend}]={backend} and conn_to_conn[{backend}]={frontend}

				Then, the server sends to the backend and frontend CONNECT,1

Reading:
	


	

