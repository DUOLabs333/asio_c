There are three parts --- the frontend (F), the server (S), and the backend (B).

Server:
	The server is started with a TCP port (specified with --port, and the default is 8222), a UNIX socket (specified with --socket, and the default is /tmp/shmem.sock), a ram file (specified with --file, and will maybe create one by default), and number of segments to create (specified with --segments, and the default is 100).

	Then, the server opens the ram file, and gets its size. By default, each segment will be given the same size (as its easier to calculate offsets), with the possibility that there may be some space on the drive left over --- there is also the possibility of dividing the space so that all of the space will be used, but some segments will be slightly bigger than others.

	Then a thread-safe set is created, and is populated with all numbers between 1 and {segments}, inclusive. An array is then created that maps each segment to their offset and size.

	A dictionary backend_to_info is then created that maps backend id to a socket connection, and a lock which will be used to make sure communication to it is thread-safe. This dictionary is thread-safe.

	A this point, the server is ready to start, so the server starts listening on the TCP port, and the socket.

Use msync with mmap. Test with backend that compares data sent with hash that is sent with it and see if it matches, and quits if any of them are false

If a duplicate backend tries to connect, just quit in BackendAccept immediately

Sockets should be shared_ptr. The TCP sockets should have Nagle's algorithm disabled.

Messages:
	The frontend and backend sends messages to the server (and vice-versa) using their respective channels. Every message is 12 bytes, and are interpreted as 3 integers of 4 bytes each. The first number always denotes the message type, and the other two numbers are used as arguments that may optionally be used. 


Backend:
	The backend can connect to the server over the unix socket S is listening on. It should continually try to connect until it does. Once it does, this will be the channel B will use.

	Once B accepts the new connection, it will immediately spawn a thread that runs the BackendAccept function.

	Inside the BackendAccept function:
		The server will perpetually listen for new messages. 

		If the server disconnects for any reason, the backend will:
			* Remove the entry from backend_to_info, if it exists
			* Relinquish control of any corresponding segments, if they exist
			* Close all corresponding frontend connections, if they exist


		The first message the backend will send upon connection is INIT,{id},{unused}. A backend's id must be globally unique. 

		Once the message is received by the backend, a new entry in backend_to_info is made, in the form of {id}: {.conn = {accepted conn}, .lock= {new lock}}

Frontend:
	The frontend can connect to the server of the TCP port S is listening on. It should continually try to connect until it does. Once it does, this will be the channel F will use.

	Once B accepts the new connection, it will immediately spawn a thread that runs the FrontendAccept function.
	
	Inside the FrontendAccept function:
		The server will perpetually listen for new messages.

		If the client disconnects, shut down everything as needed.

		The first message the client will send upon connection is CONNECT,{id},{unused}, where the id is the id of the corresponding backend it wants to connect to.
			
			First, the client will be appended to the queue at unconnected_frontends[{id}]

			The server then sends a ESTABLISH,0 message to the backend

			The backend receives the message, and makes a new connection NC to S, and waits for a response. 

			In NC's BackendAccept:
				NC sends the message ESTABLISH,{id},0

				The first client in unconnected_frontends[{id}] will be taken: conn_to_struct[{frontend}]={struct} and conn_to_struct[{backend}]={struct1}. {struct/struct1} is a pointer to a structure {.segment, .pipes, .to={backend/frontend}}

				Then, the server sends to the backend and frontend CONNECT,1 to signify that the connection establishment is complete. 

Reading:
	A side sends READ,{size} to the server.
		The side may have to send multiple of these if size > segment.size --- the returned size will be smaller than size
	

	The server acquires a segment, and sets size=min(segment.size, size).
	
	Then, the server reads size from .pipes[0], and writes it to segment
		If the read from the pipe leads to a partial read, the server should loop, appending more to the segment as needed

	Then, the server should send SEGMENT,{offset},{size}

	Then, the side should read the segment.

	Once done, the side should send back READ_DONE.

	This tells the server to release the segment

Writing:
	A side sends WRITE,{size} to the server.
		The side may have to send multiple of these if size > segment.size --- the returned size will be smaller than size
	
	The server acquires a segment, sets size=min(segment.size, size) and returns SEGMENT,{offset},{size}

	The side writes to the disk with offset and size (the returned size, NOT the original size)

	The side sends back WRITE_DONE

	The server then writes the segment to .to.pipes[1].
		If this leads to a partial write, it will have to be done in a loop 

utils:
	class OffsetSizeTracker {
		int offset
		int size

		std::tuple (int, int) decrement (int amount);

		bool is_empty()





